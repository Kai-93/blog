# <font size=7>继承和原型链</font>

## 关于原型链

下方代码说明了,new 的实例,以及其整条原型链的属性

```javascript
function A() {}
A.prototype.add = function() {
  var args = Array.prototype.slice.call(arguments)
  var count = 0
  args.forEach(function(number) {
    count += number
  })
  return count
}

var a = new A()

console.log('a.__proto__ === A.prototype: ', a.__proto__ === A.prototype)
console.log(
  'A.__proto__ === Function.prototype: ',
  A.__proto__ === Function.prototype
)
console.log(
  'Function.__proto__ === Function.prototype: ',
  Function.__proto__ === Function.prototype
)
console.log(
  'Function.__proto__.__proto__ === Object.prototype: ',
  Function.__proto__.__proto__ === Object.prototype
)
console.log(
  'Object.__proto__ === Function.prototype: ',
  Object.__proto__ === Function.prototype
)

console.log(
  'Object.__proto__.__proto__ === Object.prototype: ',
  Object.__proto__.__proto__ === Object.prototype
)

console.log(
  'Object.__proto__.__proto__.__proto__ === null: ',
  Object.__proto__.__proto__.__proto__ === null
)
```

## 关于构造

在下方代码片段中,声明了 A 函数,然后用 A new 了一个实例 a,a.constructor === A,理解为 a 由 A 构造而成,其实不然,a 本身并不拥有 constructor 属性,但是 a.**proto** === A.prototype,a 上没有,但是 A.prototype 上有,而 constructor 正是 A.prototype 拥有的,如同 add 方法一般

```javascript
function A() {}
A.prototype.add = function() {
  var args = Array.prototype.slice.call(arguments)
  var count = 0
  args.forEach(function(number) {
    count += number
  })
  return count
}

console.log('A.prototype.constructor === A: ', A.prototype.constructor === A)
console.log(
  'Function.prototype.constructor === Function: ',
  Function.prototype.constructor === Function
)
console.log(
  'Object.prototype.constructor === Object: ',
  Object.prototype.constructor === Object
)
var a = new A()
console.log('a.constructor === A: ', a.constructor === A)
console.log('a.add: ', a.add(1, 2))
console.log('a.hasOwnProperty("add"): ', a.hasOwnProperty('add'))
console.log(
  'A.prototype.hasOwnProperty("add"): ',
  A.prototype.hasOwnProperty('add')
)
console.log(
  'a.hasOwnProperty("constructor"): ',
  a.hasOwnProperty('constructor')
)
console.log(
  'A.prototype.hasOwnProperty("constructor"): ',
  A.prototype.hasOwnProperty('constructor')
)
```

## 关于继承

原型链的建立,如果上述例子中,var a = new A(),A 函数会运行并返回新构建的对象与 this 绑定,同时将 a 与 A 的原型链对象关联 2.原型链绑定后,即可沿着原型链上查找属性,即继承了属性
