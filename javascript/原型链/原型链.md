<!--
 * @Author: Kaiser
 * @Date: 2019-03-22 14:25:08
 * @Last Modified by: Kaiser
 * @Last Modified time: 2019-10-27 23:00:55
 * @Description: 原型链说明
 -->
# 原型链

## 原型链的图解

![原型链图解](./prototype.png)

[点击此处查看详情](https://www.processon.com/view/link/5db5586be4b0ece7593eaf9b)

## 关于构造

以上图为例,其实constructor属性并非number(或是其他实例化对象)的自身属性,而是来自于其原型链number.__proto__.constructor=>Number.prototype.constructor=>Number,想要表达的意思是是有Number构造了number.

## 关于继承

继承包括属性和方法,在JavaScript中,继续通过向上查找,即其主要逻辑为自身若没有该属性(或是方法),便顺着原型链(__proto__=>prototype)向上查找,直到查到Object.prototype身上,若任未找到,便会返回undefined.

## 原型链相关的方法

### XX.prototype
```JavaScript
function Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype = {
  addVertex: function(v){
    this.vertices.push(v);
  }
};

var g = new Graph();
// a.__proto__ => Graph.prototype
```

### Object.create
```JavaScript
var a = {a: 1}; 
// a.__proto__ => Object.prototype

var b = Object.create(a);
// b.__proto__ => a

var c = Object.create(b);
// c.__proto__ => b, b.__proto__ => a

var d = Object.create(null);
// b.__proto__ => null
console.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype
```

### class 
```JavaScript
class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(sideLength) {
    super(sideLength, sideLength);
  }
  get area() {
    return this.height * this.width;
  }
  set sideLength(newLength) {
    this.height = newLength;
    this.width = newLength;
  }
}

var square = new Square(2);
// square.__proto__ => Square.prototype
// Square.__proto__ => Polygon
true
```

### hasOwnProperty
